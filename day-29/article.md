# [Day29] - Lezer.js - 將自定義的 Grammar 拿到 CodeMirror 中做使用 

## 前言

在 [Day-28] 中，昨天我們用 Lezer.js 定義了一個語法讓 `(a+1)` . `(100-(2+4))` 這類的字串可以被解析。

我們來將定義好的東東拿到 CodeMirror 中使用，讓其可以被 Highlight 吧！

#### 第一步，拿出昨天我們產生的 dist/lang.js

```javascript
// This file was generated by lezer-generator. You probably shouldn't edit it.
import {LRParser} from "@lezer/lr"
export const parser = LRParser.deserialize({
  // ...some code generated by lezer-generator
})
```

#### 第二步，定義 lang.grammar

先來定義簡單的 grammar，用於解析 (100-(2+4)) 或 (a+1) 這種算式。

- @top - 代表這個 grammar 的開頭
- @expr - 代表這個 grammar 的結尾

```
@top Program { expression }

expression { Name | Number | BinaryExpression }

@skip { space | Comment }

BinaryExpression { "(" expression ("+" | "-") expression ")" }

@tokens {
  space { @whitespace+ }
  Comment { "//" ![\n]* }
  Name { @asciiLetter+ }
  Number { @digit+ }
}
```

#### 第三步，產生 dist/lang.js

```shell
lezer-generator src/lang.grammar -o dist/lang.js
```

#### 第四步，利用產生的 dist/lang.js 來 Parse 定義的語法並 Travel Tree Nodes

```javascript
import {parser} from '../dist/lang.js';

const tree = parser.parse('(a+1)');

// 利用 iterate 走訪 tree 的每個節點，並輸出節點對應資訊
tree.iterate({
  enter(node) {
    const originStr = str.substring(node.from, node.to);
    console.log('type=',node.name,' \t (from,to) =',`(${node.from},${node.to})`,' \t對應字串 =',originStr);
  },
});
/*
type= Program    (from,to) = (0,5)      對應字串 = (a+1)
type= BinaryExpression           (from,to) = (0,5)      對應字串 = (a+1)
type= Name       (from,to) = (1,2)      對應字串 = a
type= Number     (from,to) = (3,4)      對應字串 = 1
*/
```

### 參考資料

- [codemirror - 自定義語法高亮](https://codemirror.net/examples/lang-package/)
